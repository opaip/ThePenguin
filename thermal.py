
# simulation test Generated by ai

import numpy as np
# Assuming the refactored modules are named Topology and PhysicsEngine
from Topology import NetworkManager
from PhysicsEngine import Solver

def run_thermal_simulation():
    print("--- Project Penguin: Multi-Domain Simulation Kernel ---")
    print("--- Scenario: CanSat Structural Thermal Analysis ---\n")

    # 1. Initialize the Network Manager
    # In this context, the network represents the physical structure of the satellite.
    satellite_body = NetworkManager()

    # 2. Define System Parameters (First Principles Mapping)
    # Mapping Electrical concepts to Thermal Physics:
    #   - Potential (Voltage)      -> Temperature (Kelvin)
    #   - Flow (Current)           -> Heat Flux (Watts)
    #   - Resistance (Ohms)        -> Thermal Resistance (Kelvin/Watt)
    #   - Reference Node (GND)     -> Deep Space Sink (Absolute Zero / 0 K)

    # Thermal Resistance of Aluminum segments (Arbitrary values for demo)
    R_conduction = 2.5  # Resistance between structural points
    R_radiation  = 10.0 # Resistance to radiate heat to space (Node 0)

    # 3. Build the Topology (The Graph)
    # We model the satellite as a 1D rod divided into 4 segments.
    
    # Connection between Node 1 (Sun-facing side) and Node 2
    satellite_body.add_link(1, 2, R_conduction)
    
    # Connection between Node 2 and Node 3 (Internal structure)
    satellite_body.add_link(2, 3, R_conduction)
    
    # Connection between Node 3 and Node 4 (Dark side)
    satellite_body.add_link(3, 4, R_conduction)

    # Connection between Node 4 and Deep Space (Node 0 - Reference)
    # This represents heat radiating out into the void.
    satellite_body.add_link(4, 0, R_radiation)

    # 4. Initialize the Physics Engine (The Matrix Solver)
    # The engine automatically builds the Laplacian Matrix (Conductance Matrix).
    engine = Solver(satellite_body)

    # 5. Define Excitations (Input Vector)
    # We apply a Heat Flux of 100 Watts to the Sun-facing side (Node 1).
    # Nodes are sorted by ID: [Node 1, Node 2, Node 3, Node 4]
    # Input Vector B = [100W, 0W, 0W, 0W]
    
    heat_inputs = np.array([100.0, 0.0, 0.0, 0.0], dtype=np.float64)

    # 6. Solve for System State (Equilibrium Temperatures)
    print(">> Solving System Matrix for Equilibrium State...")
    temperatures = engine.compute(heat_inputs)

    # 7. Display Results
    # Output is technically 'Potential', which we interpret as Temperature.
    print("\n--- Simulation Results ---")
    print(f"Node 1 (Sun Side) Temp : {temperatures[0]:.4f} K")
    print(f"Node 2 (Mid-Body) Temp : {temperatures[1]:.4f} K")
    print(f"Node 3 (Mid-Body) Temp : {temperatures[2]:.4f} K")
    print(f"Node 4 (Radiator) Temp : {temperatures[3]:.4f} K")
    
    # Verification (First Principles Check):
    # Total Heat In = 100 W
    # Total Heat Out (via Node 4 to 0) = Temp_Node4 / R_radiation
    heat_out = temperatures[3] / R_radiation
    print(f"\n[Sanity Check] Heat Out: {heat_out:.4f} W (Should be ~100.0 W)")

if __name__ == "__main__":
    run_thermal_simulation()
